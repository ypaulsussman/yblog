---
title: GoRails Rails Concepts Notes
date: "2019-05-19"
template: "post"
draft: true
slug: "/posts/gorails-rails-concepts-notes/"
category: "What I Read"
tags:
  - "Ruby"
  - "Rails"
description: "Notes from GoRails videos."
---

## Episode 1. Environment Variables

`$PATH` is just a list of the directory paths that the shell will traverse in order to find the executable file you've specified in the current command (_throwing an error if no such executable can be found via any of the paths._) 

The `$` is only used to access an environmental variable from the terminal; in Ruby or other applications, we don't use it.

Inside `irb`, you access the hash of all environmental variable at `ENV` (or `ENV["FOOBAR"]` to access the `FOOBAR` variable.)

You use e.g. `export FOOBAR=bazquux` to set a variable for the entirety of the session (_but not across shells/sessions._)

To set a variable for all sessions, add it to `.bash_profile` or `.bashrc`.

`nvm`, `rvm`, `rbenv`, etc all work by hooking into the `$PATH` variable, then dynamically manipulating it based on whatever version's been specified from the command line. 


## Episode 2. Ruby Version Managers

`rvm` = very full-featured, but also beginner-friendly; `rbenv` is more lightweight.

`rvm` actually patches the `cd` command; `rbenv` really just adds itself to your `$PATH` and that's it.

`rvm` also provided access to gemsets (now obviated by introduction of `bundler`.)
   
   
## Episode 3. Rails Application Structure 

`config.ru` 
* example of '_rackup file_' => starts the web server; gets passed into [Unicorn, Puma, Passenger], which then hands incoming requests off to the application code   
* as such, you _could_ actually change it to e.g. `run Sinatra.application`, since Sinatra's based on Rack as well
* but it only does all this _after_ it loads the... 

`config/environment.rb` file, which
* initializes the application 
    * Files in the `/initializers` dir aren't often modified 
    * however, adding certain gems (e.g. `devise`) will require you to add new files here
    * these files are called from within `config/environment.rb`, after it loads `config/application.rb` 
* but, again, only after it loads the...

`config/application.rb` file, which
* loads `boot.rb` (_which ensures dependencies are in order: loads gemfile, runs bundler_), 
* requires the actual `rails`-gem files, then
* requires any gems specific to the current group (`:test`, `:development`, `:production`)
* includes a `module` of `class Application` that allows you to set global config items (default language, timezone, etc)

The `/locales` directory is the location for basic internationalization strings.

`routes.rb` is... well, where you declare your routes.

`secrets.yml` was introduced in Rails 4; it lets you set keys that are hardcoded in the `:test`/`:development` environments, but call on environmental variables for `:production`

The `bin` dir contains binstubs for common executables (bundle, rails, rake, spring) 
* ["Binstubs are wrapper scripts around executables"](https://github.com/rbenv/rbenv/wiki/Understanding-binstubs)
* They prepare the environment before dispatching the call to the executable
* In the Ruby world, the most common binstubs are the ones that RubyGems generates after installing a gem that contains executables.
* One common modification here is adding `pry` within the `rails` binstub

The `log` dir stores the logfiles generated by the server as it runs.

Files in the `public` dir _don't_ get compiled through the asset pipeline; they're served up directly.
 

## Episode 4. The Params Hash 

'params hash' = the `params` reserved variable inside `Controller`-class objects

Collection of data that has come to your application from various places:
* query parameters
    * k:v pairs following `?` in URL
    * k:v separated by `=`
    * pairs delimited by `&`
* route parameters
    * inside `routes.rb`, signified by `:` prefix
    * e.g. `'/blog/:id'` will assign whatever's entered into the route after `/blog/` as the value of the key `id`
    * benefit of route params: lets search engine know that you're on another page (it won't recognize this from different query params)
* form data
    * `utf8` and `authenticity_token` keys are automatically provided by rails to `form_tag` helpers; the latter [protects against CSRF](https://guides.rubyonrails.org/form_helpers.html#forms-to-external-resources)
    * You'll often also see a `commit` key, the value of which is the text on whichever `type="submit"` button was clicked


## Episode 5. Sending Data Between Controllers And Views

Within a controller method, we set instance (rather than local) variables so that views can pick them up: which occurs after the method is done being called.

Instance variables exist as long as the instance of that `FooController` class (_the instance generated for that particular HTTP request_) exists.
* that is, first the controller is instanced, and the particular action is called based on the instructions from the `routes.rb`:
    * `my_fc_instance = FooController.new`
    * `my_fc_instance.send(:myaction)`
* thus, when ERB is called as e.g. `ERB.render('myaction.html.erb,' my_fc_instance.instance_variables)`, the variables are still present.  

A local variable, by contrast, is deleted as soon as the controller action is done executing.


## Episode 6. Querying Named Scopes Across Models

Here, `merge` is simply a way of using a named scope on a joined model.

Assuming an association for which one has a scope, the following are interchangeable:

```ruby
Author.joins(:books).where("books.available = ?", true)

Author.joins(:books).merge(Book.available)
```

Whereas the following:

```ruby
Author.joins(:books).available
```

will throw an `undefined method` error, since there's no `available` method on the `Author` model.


## Episode 7. Understanding Semantic Versioning 

`>=` in a Gemfile will get you the newest version of the gem; `~>` will get you the newest _minor_ version.

Generally, prefer the latter. 

`bundle install` just implements the versions that are specified in the Gemfile; `bundle update` checks for new versions as specified by the two methods above.


## Episode 8. Routing 

Make use of `rake routes` more liberally than you currently do -- it won't help on an app as large as `acclaim-server`, but for smaller ones it could be quite useful.

`resources :foo` defines the eight CRUD routes for `:foo`; you only need to add the `do... end` block for controller actions outside of those.

Inside a `resources` block, the `member` action specifier allows for custom paths. The below...
```ruby
resources :books do
  member do
    patch :publish
  end
end
``` 

...will generate the `books/:id/publish`, on a PATCH request. 

(Normally, you'd need to define the controller and action via `patch "books/:id/publish, to: "books#publish"`; because it's inside both `resources` and `member`, though, it's inferred by Rails.)

To operate on all items in `:books`, or just generally w/o an `:id` being passed in by the route, instead use `collection`:
```ruby
resources :books do
  collection do
    patch :publish_all
    post :import
  end
end
``` 

You can retitle an entire `resources` block's URI patterns:
```ruby
resources :books, path: "products" do
#... 
end
``` 
...will listen for e.g. `/products/:id` on a GET, while still being referenced as `book` for its path helper and `books#show` for its controller action.

Devise provides you the `authenticated` method w/in your `routes.rb` file; you pass it the model it will operate on, then scope (any routes that should only be accessible by that authenticated-model) within that block:
```ruby
authenticated :admin, module: "admin" do
  resources :books do
    # ...
  end
end

resources :books, only: [:index, :show] 
```
The above will, in Rails, pass the user's session to Devise to verify that they're in fact signed-in under the `Admin` model. 

(If not, they can only access the `index` and `show` controller actions.)

Note that, to use this feature, you also need to create an `admin` dir inside `controllers`, in which you'll locate the second, authenticated `books_controller.rb` -- which would contain `class Admin::BooksController`.


## Episode 9. Forms With Multiple Submit Buttons

Classic example: blog software where you want to have one button for "_publish immediately,_" and one for "_save as draft._"

The buttons will both send back `POST` requests, but they'll be differentiated by the `commit` key on the `:params` hash (see Episode 4 for more.)

Side note: in `.erb`, if you want child HTML inside the button (for e.g. loading animations), you'll need to use `f.button` rather than `f.submit`. 
* The former creates a `button` element, which can hold children; the latter produces an `<input type="submit" .../>` element, which cannot.
* That said, with the former you'll need to explicitly add `name="commit"` and `value="my_string_for_params_hash"`.

Note that e.g. `jquery-ujs` doesn't play nicely with this multi-submit-button-per-form system -- it'll attempt to serialize into JSON the results for _each_ `f.submit`. Instead, create a hidden field with the relevant action you want to send over, then use solely `f.button` elements which, when clicked, intercept the event and instead submit a hidden field with the same name.


## Episode 10. Basic Authentication and RSS Feeds

(Explains how to create an RSS feed for users to be alerted of new screencasts via YouTube/iTunes, and how to scope the list of screencasts to whether the user's got a Pro account or not.)

BasicAuth is built into browsers and the HTTP protocol; it's very basic (so much so that no website wants to use it: it's ugly; can't do '_Forgot my password,_" etc.)

You can test BasicAuth by entering `https://${username}:${password}@domain.com`. 

By default, Devise doesn't allow BasicAuth; you can change this in the `config/initializers/devise.rb` file.

BasicAuth doesn't set a cookie to log you in permanently; it just sets that one URL in your tab as authenticated. (BasicAuth is really meant to be more per-request.)


## Episode 11. Pair Programming on Rails Scopes 

Don't forget to set your `root to: "controller#action"` on creating a new app.

When working with dates and times, be aware of how many convenience methods both [Ruby](https://ruby-doc.org/stdlib-2.6.3/libdoc/date/rdoc/Date.html#method-i-wday) and [Rails](https://api.rubyonrails.org/classes/Date.html) provide.
 
For date ranges, it's often useful to use the `..` operator to create a range, e.g. 
```ruby
scope :updated_this_month, ->{ where(updated_at: Date.today.beginning_of_month..Date.today.end_of_month) }
```

Nifty edge-case safety catch: if you're using e.g. `Time.zone.now` (or, as above, `Date.today`) multiple times in a function, call it once and assign it to a variable, on the (admittedly very-rare) chance that it's called at e.g. 23:59:59.999999 and, in between milliseconds, the time changes appreciably. 

Side note: from around 39:30 - 49:40 in the video there's a digression into switching up db's on the fly. Possibly useful for future reference in parallel with the [Rails db-configuration guides.](https://edgeguides.rubyonrails.org/configuring.html#configuring-a-database)

Lambdas: "_chunks of code that *don't* run when the app starts up_" -- constrast with literally every `class`, and class-method (like e.g. any `scope`), which actually loads and runs as the Rails app starts up. 


## Episode 12. Rails 5's ActionCable and Websockets Introduction 

Runs on two servers: one for the app, and one for ActionCable. Make sure the latter is on a multithreaded server (e.g. Puma.)

(With WebSockets you need a lot more concurrency in general, because you have all these different connections to separate clients being maintained.)

`.ru` stands for 'rackup,' not ruby'! Aha...

The `bin/cable` binstub runs that second server, using the `cable/config.ru` rackup file.

In the `config/` dir, however, there's now a `cable.yml` file inside `redis`; this sets up the [pub/sub functionality](redis.io/topics/pubsub) of ActionCable.

Inside the `app/channels` dir are the Ruby files that set up the web-server-side connection to the Redis serverr. Each file containing a class inheriting from `ApplicationCable::Channel` will set up streams to listen to the Redis pub/sub system;
    
Inside the `app/assets/javascripts/channels` dir are the JavaScript files that set up the client-side connection to the WebSocket (which then talks to the Redis channel.) 

Models that make use of ActionCable will have an `after_commit` hook that passes `self` into an `ApplicationJob`-inheriting class (inside the `jobs`) dir, which as part of its `perform` method will call to `ActionCable`. 


## Episode 13. Rails Counter Caches 

Counter caches = performance improvement (you can run one query to get the number '40,000' from the record, rather than summing each record.)

On models, remember to use e.g. `rails g model Baz foo_bar:references` to create an id that will point to a record on the `FooBar` model.

Good practice when creating a field you'll later use for a counter cache: add default and disallow `null`, as in: `t. integer :posts_count, default: 0, null: false` within the migration.

To create the cache, add it to the association within the model, e.g.:
```ruby
class ForumPost < ApplicationRecord
  belongs_to :user, counter_cache: true
# ...  
end
```
As a result of the above, creating/deleting a `ForumPost` will trigger a callback that the `counter_cache` method will perform. (That is, it always goes on the "child" model, the one with the `belongs_to`.)

In rails console, you can do e.g. `u.forum_posts.create` to make a new `ForumPost` instance which belongs to `User` (assuming `u` was an instance of `User` and there's a `belongs_to` relation on `forum_posts`.)

The actual counter-cache increment/decrement takes place at the db level (via a `COALESCE`), so it's faster than any Ruby code.

If you want to implement a counter cache on a preexisting field, you'll need to add a summing function to the migration:
```ruby
def change
  add_column :user, :forum_posts_count, :integer, default: 0, null: false
# calculating function; `reset_counters` is model class method:
  User.find_each {|u| User.reset_counters(ft.id, :forum_posts)}  
end
```
Above can be slow, though, in that it needs to load all the records into Ruby in order to access the `reset_counter` method; there's [a good example here](https://ryan.mcgeary.org/2016/02/05/proper-counter-cache-migrations-in-rails/) of the direct SQL query to add to the migration instead.

Make sure, when using a counter-cached association, to call it correctly: `u.forum_posts_count` will give you the fast, cached version; but calling `u.forum_posts.count` will actually run the full `SELECT` query.


## Episode 14. Atomic Updates And Performance with ActiveRecord Transactions 

Note: Rails already uses a `transaction` for each `.save` and `.destroy`, in order to process nested attributes (e.g. when creating a `User` model with various associations, logs, etc) and sure that either none or all connected queries succeed.

Because of inheritance, you can define a `transaction` in several different ways:
```ruby
ActiveRecord::Base.transaction do end
# is, assuming Account is a model class, the same as
Account.transaction do end
# or even
self.transaction do end
# which is the same as 
transaction do end
```  

Because a `transaction` occurs at the db-connection level, rather than the model level, it can keep track of multiple tables being updated within a single transaction. (Crucial!)

If you want to see how some Ruby code is being parsed into SQL w/o actually changing your db, wrap the relevant code in a `transaction`, then just before it ends call `raise ActiveRecord::Rollback` 

At very large record counts, `transaction` can provide a significant performance boost by letting you call `commit` just once (rather than after each save/destroy.)  


## Episode 15. Debugging: How to Interpret a Stacktrace 

_Nice walkthrough of a stack trace, but no facts immediately-visible as worth adding to your personal memory._


## Episode 16. Rails Application Templates  

Application Templates are Ruby scripts that run after app-creation to modify e.g. the Gemfile, routes, envvars, etc.

It's based on a toolkit called Thor; the documentation there is also useful.

Application Templates are called by passing the `-m` flag to `rails new` (followed by the path to the Ruby file.)

[The example template](https://github.com/excid3/jumpstart) used in this screencast is glorious, and worth at least referencing as you build future apps.
